Тестовое задание для Python/GIS-разработчика

Технологии:
Бэкенд: FastAPI
Плагин: PyQGIS API


Часть 1: Бэкенд-сервис для хранения геометрий
Задача: Написать веб-сервис на FastAPI, который будет служить хранилищем для геометрических объектов.
Требования:
- База данных:
  - Вы можете использовать SQLite для простоты. Храните геометрию в текстовом поле в формате WKT (Well-Known Text) или как GeoJSON.
  - Если вы хотите продемонстрировать более глубокие знания, использование PostgreSQL с расширением PostGIS будет огромным плюсом.
- API эндпоинты:
  - Добавление объекта: POST /features
  - Принимает в теле запроса геометрию (в формате GeoJSON) и ее тип (Point, LineString, Polygon).
  - Сохраняет объект в БД и возвращает его уникальный ID.
  - Получение всех объектов: GET /features
  - Возвращает список всех объектов из БД в формате GeoJSON Feature Collection.
  - Удаление объекта: DELETE /features/{feature_id}
  - Удаляет объект из БД по его ID.
  - Получение статистики: GET /stats
  - Возвращает JSON с количеством объектов каждого типа, например: {"points": 15, "lines": 5, "polygons": 2}.
Админка / Дашборд (опционально, но приветствуется):
  - Создайте простую веб-страницу, где можно посмотреть текущую статистику и, возможно, список последних добавленных объектов. Это можно сделать с помощью Jinja2 или любой другой удобной вам библиотеки.

Часть 2: Плагин для QGIS
Задача: Написать простой плагин для QGIS, который будет синхронизировать данные с вашим бэкенд-сервисом.
Требования:
 - Интерфейс плагина:
  - Добавьте на панель инструментов QGIS кнопку для вашего плагина. При нажатии на нее происходит подключение/синхронизация с бэкендом.
Работа со слоями:
  - Плагин должен работать с тремя векторными слоями: Points_synced, Lines_synced, Polygons_synced.
  - При первом запуске плагин должен проверять наличие этих слоев в проекте и создавать их, если они отсутствуют.
Синхронизация данных:
  - Загрузка с сервера: При нажатии на кнопку плагина, он должен делать запрос к эндпоинту GET /features, получать все объекты и добавлять их на соответствующие слои в QGIS.
  - Продумайте простой механизм, как избежать дублирования объектов при повторной синхронизации (например, можно очищать слои перед загрузкой или сверять объекты по ID).
  - Отправка на сервер: Когда пользователь рисует и сохраняет новый объект на одном из этих трех слоев, плагин должен автоматически отправлять данные этого объекта на бэкенд через эндпоинт POST /features.
  - Удаление на сервере: Когда пользователь удаляет объект с одного из этих слоев, плагин должен отправлять запрос на DELETE /features/{feature_id} для удаления соответствующего объекта в БД.

